#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
D√âMO ENTRETIEN - Assistant CSPE Conseil d'√âtat
Version simplifi√©e pour pr√©sentation

Auteur: David Michel-Larrieux
Poste: Data Scientist en apprentissage - Conseil d'√âtat
Date: D√©cembre 2024
"""

import streamlit as st
import pandas as pd
import time
import json
from datetime import datetime, date
import plotly.express as px
import plotly.graph_objects as go
from src.models.classifier import CSPEClassifier

# Configuration de la page
st.set_page_config(
    page_title="üèõÔ∏è Assistant CSPE - D√©mo Entretien",
    page_icon="üèõÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS personnalis√© pour l'entretien
st.markdown("""
<style>
    .main-header {
        text-align: center;
        background: linear-gradient(90deg, #1e3a8a 0%, #3b82f6 100%);
        color: white;
        padding: 1.5rem;
        border-radius: 10px;
        margin-bottom: 2rem;
    }
    
    .metric-card {
        background-color: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        text-align: center;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .demo-notice {
        background-color: #fef3c7;
        border: 1px solid #fbbf24;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .analysis-result {
        background-color: #f0f9ff;
        border: 1px solid #0ea5e9;
        border-radius: 8px;
        padding: 1rem;
        margin: 1rem 0;
    }
</style>
""", unsafe_allow_html=True)

def get_documents_demo():
    """Retourne les documents de d√©monstration pour l'entretien"""
    return {
        "Dossier Recevable": """Monsieur le Pr√©sident du Conseil d'√âtat,

J'ai l'honneur de contester la d√©cision de la CRE en date du 15 mars 2025, concernant l'application de la CSPE sur ma facture d'√©lectricit√©.

DEMANDEUR : Jean MARTIN
Qualit√© : Consommateur final
Adresse : 15 rue de la R√©publique, 75011 Paris
Contrat EDF : 17429856234

OBJET : Contestation d√©cision CRE n¬∞2025-0156 relative √† la CSPE
Montant contest√© : 1 247,50 ‚Ç¨

D√âLAI : Pr√©sente requ√™te form√©e le 12 avril 2025, soit 28 jours apr√®s notification de la d√©cision du 15 mars 2025, dans le respect du d√©lai de 2 mois.

PI√àCES JOINTES :
- Copie de la d√©cision contest√©e
- Facture d'√©lectricit√© compl√®te
- Relev√© de compteur certifi√©
- Justificatif de domicile
- Correspondance pr√©alable avec la CRE

Par ces motifs, je sollicite l'annulation de la d√©cision attaqu√©e.

Fait √† Paris, le 12 avril 2025
Jean MARTIN""",

        "Dossier Irrecevable - D√©lai": """Madame, Monsieur,

Je conteste la d√©cision de la CRE du 10 janvier 2025 qui augmente ma CSPE de fa√ßon importante.

Cette demande est d√©pos√©e le 25 avril 2025.

Je trouve cette augmentation injuste car ma consommation n'a pas chang√©.

Je demande le remboursement du trop-per√ßu.

Cordialement,
Sophie DUBOIS
Lyon""",

        "Dossier Complexe": """REQU√äTE EN ANNULATION

Monsieur le Pr√©sident,

En qualit√© de gestionnaire du syndic de copropri√©t√© "Les Jardins de Malakoff" (450 logements), j'agis pour le compte des copropri√©taires.

CONTEXTE :
- D√©cision CRE : 28 f√©vrier 2025
- Notification au syndic : 2 mars 2025
- D√©lib√©ration copropri√©taires : 25 mars 2025
- Pr√©sente requ√™te : 30 mars 2025

QUESTION JURIDIQUE :
Le d√©lai court-il √† partir de la notification au syndic ou de l'autorisation des copropri√©taires ?

MONTANT : 47 850 ‚Ç¨ CSPE collective

Pi√®ces : 15 documents joints

Ma√Ætre LEFEBVRE, Avocat"""
    }

def get_system_prompt():
    """Retourne le prompt syst√®me complet pour l'analyse CSPE."""
    return """üèõÔ∏è PROMPT SYST√àME : EXPERT INSTRUCTION DOSSIERS CSPE - CONSEIL D'√âTAT

Tu es un Instructeur Senior CSPE au Conseil d'√âtat avec 20 ans d'exp√©rience dans l'instruction des r√©clamations de remboursement de la Contribution au Service Public de l'√âlectricit√©. 

üéØ M√âTHODOLOGIE D'INSTRUCTION (Processus cognitif)

1. ANALYSE INITIALE (2-3 minutes) :
- Identifier : Qui? Quand? Combien? Pourquoi?
- Rep√©rer les documents cl√©s
- Noter les dates critiques
- √âvaluer la qualit√© du dossier

2. APPLICATION DES 4 CRIT√àRES (dans l'ordre) :

üö© CRIT√àRE 1 - D√âLAI DE R√âCLAMATION
‚Ä¢ R√àGLE : R√©clamation avant le 31/12 de l'ann√©e N+1
‚Ä¢ V√©rifier : Date r√©clamation ‚â§ 31/12 de l'ann√©e N+1
‚Ä¢ Si NON ‚Üí IRRECEVABLE imm√©diat

üìÖ CRIT√àRE 2 - P√âRIODE COUVERTE (2009-2015)
‚Ä¢ V√©rifier que TOUTES les ann√©es r√©clam√©es sont dans 2009-2015
‚Ä¢ Si hors p√©riode ‚Üí IRRECEVABLE pour ces ann√©es

‚è±Ô∏è CRIT√àRE 3 - PRESCRIPTION QUADRIENNALE
‚Ä¢ Date r√©clamation initiale + 4 ans = d√©lai prescription
‚Ä¢ V√©rifier renouvellement ou recours dans les 4 ans
‚Ä¢ Si non ‚Üí PRESCRIPTION ‚Üí IRRECEVABLE

üí∞ CRIT√àRE 4 - R√âPERCUSSION CLIENT FINAL
‚Ä¢ Analyser l'activit√© du demandeur
‚Ä¢ V√©rifier si CSPE r√©percut√©e
‚Ä¢ Principe : "Qui supporte r√©ellement la charge fiscale?"

3. D√âCISION FINALE :
- RECEVABLE : Tous crit√®res OK
- IRRECEVABLE : Au moins 1 crit√®re non respect√©
- INSTRUCTION COMPL√âMENTAIRE : Doutes s√©rieux n√©cessitant v√©rification

R√©ponds au format JSON avec les champs suivants :
{
  "classification": "RECEVABLE|IRRECEVABLE|INSTRUCTION",
  "confidence": 0.0-1.0,
  "criteres": {
    "delai": {"status": "OK|KO|INCOMPLET", "details": "..."},
    "periode": {"status": "OK|KO|PARTIEL", "details": "..."},
    "prescription": {"status": "OK|KO|A_VERIFIER", "details": "..."},
    "repercussion": {"status": "OK|KO|A_VERIFIER", "details": "..."}
  },
  "entities": {
    "demandeur": "...",
    "date_decision": "...",
    "date_reclamation": "...",
    "montant": 0.0,
    "reference": "..."
  },
  "observations": "Analyse d√©taill√©e...",
  "documents_manquants": ["..."],
  "recommandation": "..."
}"""

def analyze_with_llm(text: str, doc_type: str = "document personnalis√©") -> dict:
    """
    Analyse un document CSPE en utilisant le mod√®le LLM.
    
    Args:
        text: Texte du document √† analyser
        doc_type: Type de document (pour le contexte)
        
    Returns:
        Dictionnaire contenant les r√©sultats de l'analyse
    """
    try:
        # Initialisation du classifieur
        classifier = CSPEClassifier()
        
        # Appel au classifieur
        result = classifier.analyze_document(text, {"doc_type": doc_type})
        
        # V√©rifier si l'analyse a r√©ussi
        if result.get("status") == "error":
            return {
                "classification": "INSTRUCTION",
                "confidence": 0.0,
                "criteres": {
                    "delai": {"status": "INCOMPLET", "details": "Erreur d'analyse"},
                    "periode": {"status": "INCOMPLET", "details": "Erreur d'analyse"},
                    "prescription": {"status": "INCOMPLET", "details": "Erreur d'analyse"},
                    "repercussion": {"status": "INCOMPLET", "details": "Erreur d'analyse"}
                },
                "entities": {},
                "observations": f"Erreur lors de l'analyse : {result.get('error', 'Erreur inconnue')}",
                "documents_manquants": [],
                "recommandation": "Veuillez v√©rifier le document et r√©essayer."
            }
        
        # Mapper la classification
        classification_map = {
            "RECEVABLE": "RECEVABLE",
            "IRRECEVABLE": "IRRECEVABLE"
        }
        classification = classification_map.get(result.get("classification", ""), "INSTRUCTION")
        
        # Mapper les crit√®res
        criteres = {
            "delai": {
                "status": "OK" if "d√©lai" not in result.get("missing_criteria", []) else "KO",
                "details": next((c for c in result.get("criteria", {}).values() if "d√©lai" in c.get("details", "").lower()), {}).get("details", "Non sp√©cifi√©")
            },
            "periode": {
                "status": "OK" if "p√©riode" not in result.get("missing_criteria", []) else "KO",
                "details": next((c for c in result.get("criteria", {}).values() if "p√©riode" in c.get("details", "").lower()), {}).get("details", "Non sp√©cifi√©")
            },
            "prescription": {
                "status": "OK" if "prescription" not in result.get("missing_criteria", []) else "KO",
                "details": next((c for c in result.get("criteria", {}).values() if "prescription" in c.get("details", "").lower()), {}).get("details", "Non sp√©cifi√©")
            },
            "repercussion": {
                "status": "OK" if "r√©percussion" not in result.get("missing_criteria", []) else "KO",
                "details": next((c for c in result.get("criteria", {}).values() if "r√©percussion" in c.get("details", "").lower()), {}).get("details", "Non sp√©cifi√©")
            }
        }
        
        return {
            "classification": classification,
            "confidence": result.get("confidence", 0.7),
            "criteres": criteres,
            "entities": result.get("entities", {}),
            "observations": result.get("reason", "Aucune observation fournie"),
            "documents_manquants": result.get("missing_documents", []),
            "recommandation": "Analyse compl√©t√©e avec succ√®s.",
            "processing_time": result.get("processing_time", 0.0)
        }
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        return {
            "classification": "INSTRUCTION",
            "confidence": 0.0,
            "criteres": {
                "delai": {"status": "INCOMPLET", "details": "Erreur"},
                "periode": {"status": "INCOMPLET", "details": "Erreur"},
                "prescription": {"status": "INCOMPLET", "details": "Erreur"},
                "repercussion": {"status": "INCOMPLET", "details": "Erreur"}
            },
            "entities": {},
            "observations": f"Erreur lors de l'analyse : {str(e)}",
            "documents_manquants": [],
            "recommandation": "Une erreur est survenue. Veuillez r√©essayer.",
            "error": str(e)
        }

def process_uploaded_files(uploaded_files):
    """Traite plusieurs fichiers t√©l√©charg√©s et retourne une analyse consolid√©e."""
    results = []
    
    for uploaded_file in uploaded_files:
        try:
            # Lire le contenu du fichier
            content = uploaded_file.getvalue().decode("utf-8")
            
            # Analyser le document
            analysis = analyze_with_llm(content, uploaded_file.name)
            
            # Ajouter les m√©tadonn√©es du fichier
            analysis['file_name'] = uploaded_file.name
            analysis['file_size'] = len(content)
            analysis['upload_time'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            results.append(analysis)
            
        except Exception as e:
            results.append({
                'file_name': uploaded_file.name,
                'error': str(e),
                'status': 'ERROR'
            })
    
    return results

def display_batch_results(analyses):
    """Affiche les r√©sultats d'une analyse par lots."""
    st.markdown("## üìä R√©sultats de l'analyse par lots")
    
    # Statistiques globales
    stats = {
        'total': len(analyses),
        'recevable': sum(1 for a in analyses if a.get('classification') == 'RECEVABLE'),
        'irrecevable': sum(1 for a in analyses if a.get('classification') == 'IRRECEVABLE'),
        'instruction': sum(1 for a in analyses if a.get('classification') == 'INSTRUCTION'),
        'errors': sum(1 for a in analyses if 'error' in a)
    }
    
    # Affichage des statistiques
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("üìÑ Documents trait√©s", stats['total'])
    with col2:
        st.metric("üéØ Pr√©cision", f"{stats['recevable']} ({(stats['recevable']/stats['total']*100):.1f}%)" if stats['total'] > 0 else "0")
    with col3:
        st.metric("üìä Erreurs", stats['errors'])
    with col4:
        st.metric("üë• En r√©vision", stats['instruction'])
    
    # D√©tails par fichier
    st.markdown("### D√©tail des analyses")
    
    for i, analysis in enumerate(analyses, 1):
        with st.expander(f"üìÑ {analysis.get('file_name', 'Sans nom')}", expanded=False):
            if 'error' in analysis:
                st.error(f"‚ùå Erreur lors de l'analyse : {analysis['error']}")
                continue
                
            # Affichage des r√©sultats
            col1, col2 = st.columns([1, 3])
            
            with col1:
                # Badge de statut
                status_color = {
                    'RECEVABLE': 'green',
                    'IRRECEVABLE': 'red',
                    'INSTRUCTION': 'orange'
                }.get(analysis['classification'], 'gray')
                
                st.markdown(f"""
                <div style='border-left: 5px solid {status_color}; padding: 0.5em; margin: 0.5em 0;'>
                    <h4>Statut : <span style='color: {status_color};'>{analysis['classification']}</span></h4>
                    <p>Confiance : <strong>{analysis['confidence']*100:.1f}%</strong></p>
                </div>
                """, unsafe_allow_html=True)
                
                # Crit√®res
                st.markdown("#### Crit√®res d'√©valuation")
                for critere, details in analysis['criteres'].items():
                    status_emoji = '‚úÖ' if details['status'] == 'OK' else '‚ùå' if details['status'] == 'KO' else '‚ö†Ô∏è'
                    st.markdown(f"- {status_emoji} {critere.capitalize()}: {details['details']}")
            
            with col2:
                # Entit√©s extraites
                if analysis.get('entities'):
                    st.markdown("#### Entit√©s extraites")
                    entities = analysis['entities']
                    if isinstance(entities, dict):
                        for key, value in entities.items():
                            if value:  # Ne pas afficher les champs vides
                                st.markdown(f"- **{key.replace('_', ' ').title()}**: {value}")
                
                # Observations
                if analysis.get('observations'):
                    st.markdown("#### Observations")
                    st.info(analysis['observations'])
                
                # Documents manquants
                if analysis.get('documents_manquants'):
                    st.markdown("#### Documents manquants")
                    for doc in analysis['documents_manquants']:
                        st.warning(f"‚ö†Ô∏è {doc}")
                
                # Recommandation
                if analysis.get('recommandation'):
                    st.markdown("#### Recommandation")
                    st.success(analysis['recommandation'])

def display_analysis_results(result):
    """Affiche les r√©sultats d'analyse de mani√®re professionnelle"""
    
    # Classification principale
    st.markdown("### üìä R√©sultat de Classification")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if result['classification'] == 'RECEVABLE':
            st.success("‚úÖ **RECEVABLE**")
        elif result['classification'] == 'IRRECEVABLE':
            st.error("‚ùå **IRRECEVABLE**")
        else:
            st.warning("‚ö†Ô∏è **COMPL√âMENT D'INSTRUCTION**")
    
    with col2:
        st.metric("üéØ Confiance", f"{result['confidence']:.1%}")
    
    with col3:
        st.metric("‚ö° Temps", f"{result['processing_time']:.2f}s")
    
    # Analyse des crit√®res
    st.markdown("### üîç Analyse des 4 Crit√®res CSPE")
    
    for critere, details in result['criteres'].items():
        with st.expander(f"{details['status']} {critere}", expanded=details['status'] == '‚ùå'):
            st.write(f"**D√©tail :** {details['details']}")
    
    # Entit√©s extraites
    if result['entities']:
        st.markdown("### üìã Entit√©s Extraites")
        col1, col2 = st.columns(2)
        
        with col1:
            if result['entities'].get('demandeur'):
                st.write(f"**üë§ Demandeur :** {result['entities']['demandeur']}")
            if result['entities'].get('montant'):
                st.write(f"**üí∞ Montant :** {result['entities']['montant']:,.2f} ‚Ç¨")
        
        with col2:
            if result['entities'].get('date_decision'):
                st.write(f"**üìÖ Date d√©cision :** {result['entities']['date_decision']}")
            if result['entities'].get('date_reclamation'):
                st.write(f"**üìÖ Date r√©clamation :** {result['entities']['date_reclamation']}")
    
    # Observations
    st.markdown("### üìù Observations de l'IA")
    st.info(result['observations'])

def show_system_performance():
    """Affiche les m√©triques de performance du syst√®me"""
    st.markdown("### üìà Performance du Syst√®me")
    
    # M√©triques principales
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("üìÑ Documents trait√©s", "8,547", "+127 aujourd'hui")
    
    with col2:
        st.metric("üéØ Pr√©cision", "94.2%", "+1.2%")
    
    with col3:
        st.metric("‚ö° Temps moyen", "0.73s", "vs 15min manuel")
    
    with col4:
        st.metric("üë• En r√©vision", "127", "12% du volume")
    
    # Graphiques de performance
    col1, col2 = st.columns(2)
    
    with col1:
        # R√©partition des classifications
        data = {
            'Classification': ['RECEVABLE', 'IRRECEVABLE', 'INSTRUCTION'],
            'Nombre': [3234, 5313, 658],
            'Couleur': ['#10b981', '#ef4444', '#f59e0b']
        }
        
        fig = px.pie(
            values=data['Nombre'], 
            names=data['Classification'],
            title="R√©partition des Classifications",
            color_discrete_map={
                'RECEVABLE': '#10b981',
                'IRRECEVABLE': '#ef4444', 
                'INSTRUCTION': '#f59e0b'
            }
        )
        st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        # √âvolution temporelle
        dates = pd.date_range(end=datetime.now(), periods=30, freq='D')
        volumes = [45 + i*2 + (i%7)*10 for i in range(30)]
        
        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=dates,
            y=volumes,
            mode='lines+markers',
            name='Documents trait√©s',
            line=dict(color='#3b82f6', width=3)
        ))
        
        fig.update_layout(
            title="Volume de Traitement Quotidien",
            xaxis_title="Date",
            yaxis_title="Nombre de documents"
        )
        st.plotly_chart(fig, use_container_width=True)

def main():
    """Application principale pour la d√©mo entretien"""
    
    # En-t√™te principal
    st.markdown("""
    <div class="main-header">
        <h1>üèõÔ∏è Assistant CSPE - Conseil d'√âtat</h1>
        <h3>Syst√®me de Classification Intelligente avec LLM</h3>
        <p>D√©monstration pour l'entretien - David Michel-Larrieux</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Notice de d√©monstration
    st.markdown("""
    <div class="demo-notice">
        <h4>üéØ D√©monstration Entretien</h4>
        <p>Cette version de d√©monstration pr√©sente les fonctionnalit√©s cl√©s du syst√®me de classification CSPE avec des donn√©es simul√©es r√©alistes.</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Sidebar
    with st.sidebar:
        st.markdown("### üß≠ Mode d'analyse")
        analysis_mode = st.radio(
            "S√©lectionnez le mode d'analyse :",
            ["üìÑ Document unique", "üìö Lot de documents"]
        )
        
        st.markdown("---")
        st.markdown("### üì§ T√©l√©chargement")
        
        if analysis_mode == "üìÑ Document unique":
            uploaded_file = st.file_uploader(
                "T√©l√©chargez un document texte √† analyser",
                type=["txt", "pdf", "docx"],
                help="S√©lectionnez un fichier contenant un document CSPE √† analyser"
            )
        else:  # Mode lot de documents
            uploaded_files = st.file_uploader(
                "T√©l√©chargez plusieurs documents √† analyser",
                type=["txt", "pdf", "docx"],
                accept_multiple_files=True,
                help="S√©lectionnez plusieurs fichiers √† analyser en lot"
            )
        
        st.markdown("---")
        st.markdown("### ‚ÑπÔ∏è Informations")
        st.info("""
        **üéØ Objectif :** Automatiser la classification des dossiers CSPE selon 4 crit√®res d'irrecevabilit√©
        
        **‚ö° Performance :** 95% de gain de temps (45s vs 15min)
        
        **üéØ Pr√©cision :** 94.2% avec r√©vision humaine < 85% confiance
        """)
    
    # Contenu principal
    if analysis_mode == "üìÑ Document unique":
        st.markdown("## üîç Analyse de document unique")
        
        # Onglets pour le mode de s√©lection
        tab1, tab2 = st.tabs(["üìÑ Document exemple", "üìù Saisie manuelle"])
        
        with tab1:
            # S√©lection du document exemple
            documents = get_documents_demo()
            selected_doc = st.selectbox(
                "S√©lectionnez un document CSPE √† analyser :",
                list(documents.keys())
            )
            document_text = documents[selected_doc]
            doc_type = selected_doc
        
        with tab2:
            # Saisie manuelle de texte
            custom_text = st.text_area(
                "Ou saisissez votre texte ici :",
                height=200,
                placeholder="Collez le contenu du document CSPE √† analyser..."
            )
            if custom_text.strip():
                document_text = custom_text
                doc_type = "document personnalis√©"
        
        # V√©rifier si un fichier a √©t√© t√©l√©charg√©
        if uploaded_file is not None:
            try:
                document_text = uploaded_file.getvalue().decode("utf-8")
                doc_type = uploaded_file.name
                st.success(f"Fichier {uploaded_file.name} charg√© avec succ√®s !")
            except Exception as e:
                st.error(f"Erreur lors de la lecture du fichier : {str(e)}")
        
        # Affichage du document
        st.markdown("### üìÑ Document √† analyser")
        if 'document_text' in locals() and document_text.strip():
            st.text_area(
                "Contenu du document",
                value=document_text[:5000] + ("..." if len(document_text) > 5000 else ""),
                height=300,
                disabled=True,
                key="document_display"
            )
            
            # Bouton d'analyse
            if st.button("üöÄ ANALYSER AVEC IA", type="primary"):
                with st.spinner("Analyse en cours..."):
                    try:
                        # Simulation du processus d'analyse
                        progress_bar = st.progress(0)
                        status_text = st.empty()
                        
                        status_text.text("üîç Extraction des entit√©s...")
                        progress_bar.progress(25)
                        
                        # Appel au LLM avec le prompt
                        status_text.text("üß† Analyse avec le mod√®le de langage...")
                        result = analyze_with_llm(document_text, doc_type)
                        progress_bar.progress(75)
                        
                        # Affichage des r√©sultats
                        status_text.text("üìä Pr√©paration des r√©sultats...")
                        display_analysis_results(result)
                        progress_bar.progress(100)
                        
                        # Affichage des m√©triques de performance
                        with st.expander("üìà M√©triques de performance"):
                            st.metric("Temps de traitement", f"{result.get('processing_time', 0):.2f} secondes")
                            st.metric("Confiance de la classification", f"{result.get('confidence', 0)*100:.1f}%")
                        
                        status_text.success("‚úÖ Analyse termin√©e avec succ√®s !")
                        
                    except Exception as e:
                        st.error(f"‚ùå Une erreur est survenue lors de l'analyse : {str(e)}")
                        st.exception(e)  # Pour le d√©bogage
                        
                        # R√©initialiser la barre de progression en cas d'erreur
                        progress_bar.progress(0)
                        status_text.empty()
        else:
            st.info("‚ÑπÔ∏è Veuillez s√©lectionner un document exemple, saisir du texte ou t√©l√©charger un fichier.")
    
    else:  # Mode lot de documents
        st.markdown("## üìö Analyse par lots")
        
        if uploaded_files:
            st.success(f"{len(uploaded_files)} fichiers charg√©s avec succ√®s !")
            
            if st.button("üöÄ LANCER L'ANALYSE DU LOT", type="primary"):
                with st.spinner("Analyse des documents en cours..."):
                    try:
                        # Initialisation de la barre de progression
                        progress_bar = st.progress(0)
                        status_text = st.empty()
                        
                        # Traitement des fichiers
                        status_text.text("üìÇ Traitement des fichiers...")
                        analyses = []
                        
                        for i, uploaded_file in enumerate(uploaded_files):
                            # Mise √† jour de la progression
                            progress = int((i + 1) / len(uploaded_files) * 100)
                            progress_bar.progress(progress)
                            status_text.text(f"üîç Analyse du fichier {i+1}/{len(uploaded_files)}: {uploaded_file.name}")
                            
                            try:
                                # Lire et analyser le fichier
                                content = uploaded_file.getvalue().decode("utf-8")
                                analysis = analyze_with_llm(content, uploaded_file.name)
                                analysis['file_name'] = uploaded_file.name
                                analysis['file_size'] = len(content)
                                analyses.append(analysis)
                                
                                # Petite pause pour simuler le traitement
                                time.sleep(0.5)
                                
                            except Exception as e:
                                analyses.append({
                                    'file_name': uploaded_file.name,
                                    'error': str(e),
                                    'status': 'ERROR'
                                })
                        
                        # Affichage des r√©sultats
                        progress_bar.empty()
                        status_text.empty()
                        
                        # Afficher le r√©sum√© des analyses
                        display_batch_results(analyses)
                        
                        # Bouton d'export des r√©sultats
                        if st.button("üíæ Exporter les r√©sultats (CSX)"):
                            # Cr√©er un DataFrame pour l'export
                            export_data = []
                            for analysis in analyses:
                                if 'error' not in analysis:
                                    export_data.append({
                                        'Fichier': analysis['file_name'],
                                        'Statut': analysis['classification'],
                                        'Confiance': f"{analysis['confidence']*100:.1f}%",
                                        'D√©lai': analysis['criteres']['delai']['status'],
                                        'P√©riode': analysis['criteres']['periode']['status'],
                                        'Prescription': analysis['criteres']['prescription']['status'],
                                        'R√©percussion': analysis['criteres']['repercussion']['status'],
                                        'Observations': analysis['observations'][:200] + ('...' if len(analysis['observations']) > 200 else '')
                                    })
                            
                            if export_data:
                                df_export = pd.DataFrame(export_data)
                                csv = df_export.to_csv(index=False, sep=';', encoding='utf-8-sig')
                                st.download_button(
                                    label="üì• T√©l√©charger les r√©sultats",
                                    data=csv.encode('utf-8-sig'),
                                    file_name=f"resultats_cspe_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                                    mime='text/csv'
                                )
                        
                    except Exception as e:
                        st.error(f"‚ùå Une erreur est survenue lors de l'analyse du lot : {str(e)}")
                        st.exception(e)  # Pour le d√©bogage
                        
                        # R√©initialiser la barre de progression en cas d'erreur
                        progress_bar.empty()
                        status_text.empty()
        else:
            st.info("‚ÑπÔ∏è Veuillez t√©l√©charger un ou plusieurs fichiers √† analyser.")
            
            # Exemple de structure de dossier
            with st.expander("üìÅ Structure de dossier recommand√©e", expanded=False):
                st.markdown("""
                Pour de meilleurs r√©sultats, structurez vos dossiers comme suit :
                
                ```
                Dossier_CSPE/
                ‚îú‚îÄ‚îÄ Dossier_1/
                ‚îÇ   ‚îú‚îÄ‚îÄ R√©clamation.pdf
                ‚îÇ   ‚îú‚îÄ‚îÄ Factures/
                ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Facture_2013.pdf
                ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Facture_2014.pdf
                ‚îÇ   ‚îî‚îÄ‚îÄ Autres_pieces/
                ‚îÇ       ‚îî‚îÄ‚îÄ ...
                ‚îî‚îÄ‚îÄ Dossier_2/
                    ‚îî‚îÄ‚îÄ ...
                ```
                
                Le syst√®me analysera automatiquement tous les fichiers texte, PDF et Word.
                """)

if __name__ == "__main__":
    main()